use runtime::time::*;
use std::{sync::Arc, time::Duration};
use thespian::*;

#[runtime::main]
async fn main() {
    // Spawn the actor as a concurrent task.
    let actor = MyActor::default().start();

    // Communicate asynchronously with the actor from the current task, transparently
    // using message passing under the hood.
    loop {
        Delay::new(Duration::from_secs(3)).await;
        let id = actor
            .add_id(1)
            .await
            .expect("Failed to invoke `add_id` on actor");
        println!("New ID: {}", id);
    }
}

#[derive(Debug, Default)]
pub struct MyActor {
    name: Arc<String>,
    id: usize,
}

#[thespian::actor]
impl MyActor {
    pub fn name(&self) -> Arc<String> {
        self.name.clone()
    }

    pub fn set_name(&mut self, name: String) {
        self.name = Arc::new(name);
    }

    pub async fn add_id(&mut self, value: usize) -> usize {
        self.id += value;
        self.id
    }
}

/// ============================================================================
/// Boilerplate - Should be generated by proc macros
/// ============================================================================

#[allow(bad_style)]
mod thespian_generated__MyActor {
    use crate::MyActor;
    use futures::{prelude::*, select};
    use std::{future::Future, sync::Arc};
    use thespian::*;

    impl Actor for MyActor {
        type Context = MyActorContext;
        type Proxy = MyActorProxy;
    }

    pub struct MyActorContext {
        receiver__name: MessageReceiver<MyActor__name, Arc<String>>,
        receiver__add_id: MessageReceiver<MyActor__add_id, usize>,
    }

    impl ActorContext for MyActorContext {
        fn into_future(self) -> Box<dyn Future<Output = ()>> {
            Box::new(async move {
                let mut receiver__name = self.receiver__name.fuse();
                let mut receiver__add_id = self.receiver__add_id.fuse();

                loop {
                    select! {
                        name_message = receiver__name.next() => {
                            unimplemented!();
                        },

                        add_id_message = receiver__add_id.next() => {
                            unimplemented!();
                        }
                    }
                }
            })
        }
    }

    pub struct MyActorProxy {
        sender__name: MessageSender<MyActor__name, Arc<String>>,
        sender__add_id: MessageSender<MyActor__add_id, usize>,
    }

    impl MyActorProxy {
        pub async fn name(&self) -> Result<Arc<String>, MessageError> {
            self.sender__name.send(MyActor__name).await
        }

        pub async fn add_id(&self, value: usize) -> Result<usize, MessageError> {
            self.sender__add_id.send(MyActor__add_id(value)).await
        }
    }

    impl ActorProxy for MyActorProxy {
        type Actor = MyActor;
    }

    #[derive(Debug)]
    struct MyActor__name;

    #[derive(Debug)]
    struct MyActor__add_id(usize);
}
